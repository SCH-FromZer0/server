import database from '../../infra/connector/database';
import InvitationEntity from "./invitation.entity";
import {isUUID} from "class-validator";
import {IsNull, Not, Or} from "typeorm";
import ApplyEntity from "../apply/apply.entity";
import Invitation from "../../service/invitation";

type ConditionType = {
    [id in keyof InvitationEntity]?: InvitationEntity[id]
}
type FindExistingReturnType<T extends 'count' | 'get'> = T extends 'count' ? number : InvitationEntity[];

const invitationRepository = database.source.getRepository(InvitationEntity).extend({
    async findById(id: string): Promise<InvitationEntity | null> {
        if(!isUUID(id)) return null;
        return await this.findOneById(id);
    },

    async getAll(includeUsed?: boolean): Promise<InvitationEntity[]> {
        return this.find({
            withDeleted: includeUsed ?? false,
        })
    },

    async add(invitation: InvitationEntity): Promise<boolean> {
        return await this.save(invitation);
    },

    async addFromApplication(application: ApplyEntity) {
        return await this.save(new InvitationEntity(
            application.name,
            application.email,
            application.phone,
            true,
            null,
            application.studentId
        ));
    },

    async addManually({name, email, phone, isInternal, issuerId, studentId, association}: {
        name: string,
        email: string,
        phone: string,
        isInternal: boolean,
        issuerId: string,
        studentId?: number,
        association?: string
    }) {
        const invitation = new InvitationEntity(name, email, phone, isInternal, issuerId);
        if(studentId) invitation.studentId = studentId;
        if(association) invitation.association = association;

        return await this.save(invitation);
    },

    async used(invitation: string | InvitationEntity): Promise<boolean> {
        return await this.softDelete(
            typeof invitation === 'object' ? invitation.id : invitation
        );
    },

    async invoke(invitation: string | InvitationEntity): Promise<boolean> {
        return await this.delete(
            typeof invitation === 'object' ? invitation.id : invitation
        );
    },

    async findExistingInvitation<T extends 'count' | 'get'>({name, studentId, phone, email, mode, operator = 'or'}: {
        name?: string,
        studentId?: number,
        phone?: string,
        email?: string,
        mode: T,
        operator?: 'or' | 'and'
    }): Promise<FindExistingReturnType<T>> {
        const _condition: ConditionType = {};

        if (name) _condition.name = name;
        if (studentId) _condition.studentId = studentId;
        if (phone) _condition.phone = phone;
        if (email) _condition.email = email;

        const condition: ConditionType | ConditionType[] = operator === 'and' ? _condition : [];

        if (operator === 'or' && Array.isArray(condition))
            await Promise.all(Object.entries(_condition).map(([key, value]: [string, string | number]) => {
                condition.push({
                    [key]: value
                })
            }))

        switch (mode) {
            case 'count':
                return this.count({
                    where: condition
                });
            case 'get':
                return this.find({
                    where: condition
                });
            default:
                return null;
        }
    },

    async getBrief() {
        return {
            created: await this.count({
                withDeleted: true,
            }),
            autoGenerated: await this.count({
                where: {
                    issuerId: IsNull()
                }
            }),
            manualGenerated: await this.count({
                where: {
                    issuerId: Not(IsNull())
                }
            }),
            unused: await this.count({
                where: {
                    usedAt: IsNull()
                }
            }),
        };
    },

    async _getBrief() {
        const result = await this.find({
            select: ['id', 'studentId', 'name', 'issuerId']
        });
        return await Promise.all(result.map((invitation: {
            id: string,
            studentId: number,
            name: string,
            issuerId: string
        }) => {
            return {
                id: invitation.id,
                studentId: invitation.studentId,
                name: invitation.name,
                issuedBy: invitation.issuerId ?? '자동 생성됨'
            }
        }));
    }
})

export default invitationRepository;
